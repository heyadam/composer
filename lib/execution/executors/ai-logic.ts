/**
 * AI Logic Node Executor
 *
 * Executes custom transformation code on inputs.
 * Can use cached code, dynamic code from input, or auto-generate code from prompt.
 */

import type { NodeExecutor, ExecutionContext, ExecuteNodeResult } from "./types";
import { fetchWithTimeout } from "../utils/fetch";
import { buildApiRequestBody } from "../utils/request";

export const aiLogicExecutor: NodeExecutor = {
  type: "ai-logic",
  hasPulseOutput: true,

  async execute(ctx: ExecutionContext): Promise<ExecuteNodeResult> {
    const { node, inputs, apiKeys, signal, options } = ctx;

    // Check if transform input is connected (dynamic) or using cached code
    const transformInput = inputs["transform"];
    const cachedCode = node.data.generatedCode as string | undefined;
    const transformPrompt = node.data.transformPrompt as string | undefined;

    let codeToExecute: string;
    let autoGeneratedCode: string | undefined;
    let autoGeneratedExplanation: string | undefined;

    // Helper to generate code via API
    const generateCode = async (prompt: string) => {
      const baseFields = { type: "magic-generate" as const, prompt };
      const body = buildApiRequestBody(baseFields, apiKeys, options);

      const response = await fetchWithTimeout("/api/execute", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
        signal,
      });

      if (!response.ok) {
        const err = await response.json();
        throw new Error(err.error || "Failed to generate code");
      }

      return response.json();
    };

    if (transformInput) {
      // Dynamic: generate code from connected transform input
      const result = await generateCode(transformInput);
      codeToExecute = result.code;
    } else if (cachedCode) {
      // Static: use cached generated code
      codeToExecute = cachedCode;
    } else if (transformPrompt?.trim()) {
      // Auto-generate: no cached code but has a prompt, generate on the fly
      const result = await generateCode(transformPrompt);
      codeToExecute = result.code;
      // Track auto-generated code so it can be persisted to the node
      autoGeneratedCode = result.code;
      autoGeneratedExplanation = result.explanation;
    } else {
      throw new Error("No code generated. Click 'Generate Logic' first or connect a transform input.");
    }

    try {
      // Create function from generated code
      // The code should be a function body that starts with "return"
      const fn = new Function("input1", "input2", `"use strict"; ${codeToExecute}`);

      // Parse inputs - they can be strings or numbers
      const parseInput = (value: string | undefined): string | number | null => {
        if (value === undefined || value === "") return null;
        // Try to parse as number
        const num = Number(value);
        return isNaN(num) ? value : num;
      };

      // Check for named handles first, fall back to "prompt" for edges without targetHandle
      const input1 = parseInput(inputs["input1"] ?? inputs["prompt"]);
      const input2 = parseInput(inputs["input2"]);

      // Execute the function
      const result = fn(input1, input2);

      return {
        output: String(result ?? ""),
        generatedCode: autoGeneratedCode,
        codeExplanation: autoGeneratedExplanation,
      };
    } catch (err) {
      throw new Error(`Code execution error: ${err instanceof Error ? err.message : "Unknown error"}`);
    }
  },
};
